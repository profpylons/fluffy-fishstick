# Game Data Chat - Windsurf AI Rules (Monorepo)

You are an expert TypeScript/Next.js developer working on a game data analytics chat application using a **monorepo architecture**.

## Core Rules

1. **MONOREPO STRUCTURE** - Two separate packages: `chat-app` (UI) and `mcp-server` (tools)
2. **TRUE MCP ARCHITECTURE** - Chat app uses Claude AI with MCP protocol to call tools in MCP server
3. **NEVER duplicate schema definitions** - All tool schemas defined ONCE in `mcp-server/src/mcp-tools.ts`
4. **ALWAYS provide friendly error messages** - Use emoji indicators (‚ùå, üí°, üìù) in console, user-friendly messages in UI
5. **USE proper TypeScript** - Strict typing, avoid `any` except in error handlers
6. **HANDLE hydration** - Client-only rendering for timestamps and locale-specific data

## Tech Stack

- **Chat App**: Next.js 15, React 19, Tailwind CSS, Claude 3.5 Sonnet, MCP Client
- **MCP Server**: Node.js, TypeScript, MCP SDK, Zod validation, RAWG API
- **Protocol**: Model Context Protocol (stdio transport)

## Monorepo Structure

```
packages/
‚îú‚îÄ‚îÄ chat-app/          # Next.js UI + Claude + MCP Client
‚îî‚îÄ‚îÄ mcp-server/        # MCP Server + Game data tools
```

## Architecture Flow

```
User ‚Üí Chat App ‚Üí Claude AI ‚Üí MCP Protocol ‚Üí MCP Server ‚Üí RAWG API
```

## Package Responsibilities

### chat-app
- Next.js UI and routing
- Claude AI integration
- MCP Client (connects to MCP server)
- User interface components
- **DOES NOT** contain tool logic

### mcp-server
- MCP Server implementation
- Tool definitions (fetch_game_data)
- Tool execution logic
- RAWG API integration
- **DOES NOT** contain UI logic

## Critical Patterns

### When Adding Tools

1. **Edit `packages/mcp-server/src/mcp-tools.ts`** - Define tool schema and execution
2. **Register in `packages/mcp-server/src/mcp-server.ts`** - Register with MCP server
3. **Rebuild MCP server** - `npm run build --workspace=mcp-server`
4. **Chat app auto-discovers** - No changes needed in chat-app!

### MCP Client Connection

The chat app connects to MCP server via stdio:

```typescript
const transport = new StdioClientTransport({
  command: 'node',
  args: ['../../mcp-server/dist/index.js'],
});
await mcpClient.connect(transport);
```

### Tool Calling Flow

1. User sends message
2. Claude decides to use tool
3. Chat app calls MCP server via protocol
4. MCP server executes tool
5. Result sent back to Claude
6. Claude generates response

## File Locations

### Chat App Files
- `packages/chat-app/src/lib/claude-mcp.ts` - Claude + MCP client
- `packages/chat-app/src/app/api/chat/route.ts` - Chat API
- `packages/chat-app/src/components/*` - UI components

### MCP Server Files
- `packages/mcp-server/src/mcp-tools.ts` - ‚≠ê SINGLE SOURCE OF TRUTH
- `packages/mcp-server/src/mcp-server.ts` - MCP server setup
- `packages/mcp-server/src/rawg.ts` - RAWG API client

## Development Commands

```bash
npm run dev              # Run chat app only
npm run dev:mcp          # Run MCP server only
npm run dev:all          # Run both
npm run build            # Build all packages
```

## DO ‚úÖ

- Keep UI logic in chat-app
- Keep tool logic in mcp-server
- Use MCP protocol for communication
- Define schemas once in mcp-server
- Rebuild mcp-server after tool changes
- Use Claude 3.5 Sonnet for AI
- Handle errors gracefully in both packages

## DON'T ‚ùå

- Mix UI and tool logic
- Duplicate tool definitions
- Call RAWG API directly from chat-app
- Hardcode API keys
- Skip rebuilding mcp-server after changes
- Use Gemini (we switched to Claude for MCP support)

## Environment Variables

**chat-app/.env.local**:
```
ANTHROPIC_API_KEY=your_key
```

**mcp-server/.env.local**:
```
RAWG_API_KEY=your_key
```

## Key Benefits

1. **Separation** - UI and tools are independent
2. **Reusability** - MCP server works with any MCP client
3. **Scalability** - Add tools without touching UI
4. **Type Safety** - TypeScript + Zod throughout
5. **True MCP** - Proper protocol implementation

## Reference Docs

- `README-MONOREPO.md` - Monorepo setup and architecture
- `MCP_INTEGRATION.md` - MCP protocol details
- `SCHEMA_CONVERSION.md` - Schema patterns
- `ERROR_HANDLING.md` - Error handling
